{"meta":{"title":"Hanson的博客","subtitle":null,"description":null,"author":"Hanson Zhang","url":"http://myhanson.com"},"pages":[{"title":"Categories","date":"2017-11-09T03:42:36.037Z","updated":"2017-11-09T03:36:31.247Z","comments":true,"path":"categories/index.html","permalink":"http://myhanson.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-09T03:42:36.048Z","updated":"2017-11-09T03:36:31.248Z","comments":true,"path":"tags/index.html","permalink":"http://myhanson.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HSStockChart介绍","slug":"HSStockChart介绍","date":"2017-11-04T08:13:47.448Z","updated":"2017-11-09T05:54:30.109Z","comments":true,"path":"2017/11/04/HSStockChart介绍/","link":"","permalink":"http://myhanson.com/2017/11/04/HSStockChart介绍/","excerpt":"HSStockChart 是一个绘制股票分时图、K 线图的库。支持流畅的回弹拖动，长按十字线，捏合放大缩小等功能，主要使用了 CAShapeLayer 来绘图，相比使用 Core Graphics 和重写 drawRect 的方法更高效，占用内存更小。GitHub 地址：HSStockChart","text":"HSStockChart 是一个绘制股票分时图、K 线图的库。支持流畅的回弹拖动，长按十字线，捏合放大缩小等功能，主要使用了 CAShapeLayer 来绘图，相比使用 Core Graphics 和重写 drawRect 的方法更高效，占用内存更小。GitHub 地址：HSStockChart 功能 支持绘制分时图，五日分时图，K 线图，MA 线指标，交易量柱等。 支持横屏查看。 K 线图利用 UIScrollView 达到流畅的滑动查看效果。 使用 CAShapeLayer 绘图，内存占用更小，效率更高。 版本需求 iOS 8.0+ Swift 3 说明 之前绘图的方法是重写 drawRect 方法，在方法里获取 CGContext 然后利用Core Graphics 来进行绘图，调用 setNeedsDisplay 来刷新。但是这种方法有个问题是： 一旦你实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的内存可从这个公式得出：图层宽x图层高x4字节，宽高的单位均为像素。对于一个在 Retina iPad 上的全屏图层来说，这个内存量就是 2048x1526x4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。【摘自 iOS Core Animation- Advanced Techniques 中文译本 高效绘图一章】 因为我要达到流畅滑动查看的效果，所以在 UIScrollView 上添加了一个 UIView 这个 View 的宽度会依据当前展示数据的多少而变化，结合 UIScrollView 的 ContentSize 就能达到很好的滑动效果。 如果我用之前重写 drawRect 的方法，那么这个 View 会根据数据量的变大而变大，从而导致绘图内存急剧上升，数据量大的时候会崩溃。基于此，我采用了 CAShapeLayer 的方式绘图，此方式的特点如下： CAShapeLayer 是一个通过矢量图形而不是 bitmap 来绘制的图层子类。你指定诸如颜色和线宽等属性，用 CGPath 来定义想要绘制的图形，最后就自动渲染出来了。当然，你也可以用 Core Graphics 直接向原始的内容中绘制一个路径，相比之下，使用 CAShapeLayer 有以下一些优点: 渲染快速。CAShapeLayer 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。 高效使用内存。一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 不会被图层边界剪裁掉，一个 CAShapeLayer 可以在边界之外绘制。你的图层路径不会像在使用 Core Graphics 的普通 CALayer 一样被剪裁掉。 不会出现像素化。当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化 最终在真机上测试(注意是在真机上测试)两种方式的结果如图，内存大大降低并且稳定在13M左右 自定义 CAShapeLayer，重写 action(forKey event: String) 方法。目的是 关闭 CAShapeLayer 的隐式动画，避免滑动时候或者十字线出现时有残影的现象(实际上是因为 Layer 的 position 属性变化而产生的隐式动画) 12345class HSCAShapeLayer: CAShapeLayer &#123; override func action(forKey event: String) -&gt; CAAction? &#123; return nil &#125;&#125; LicenseReleased under MIT License.","categories":[],"tags":[]},{"title":"自定义 UISegmentedControl 样式","slug":"自定义 UISegmentedControl 样式","date":"2017-11-04T08:13:47.448Z","updated":"2017-11-09T05:54:04.049Z","comments":true,"path":"2017/11/04/自定义 UISegmentedControl 样式/","link":"","permalink":"http://myhanson.com/2017/11/04/自定义 UISegmentedControl 样式/","excerpt":"系统的 UISegmentedControl 是个挺方便的控件，这里来讲讲在 Swift3 下自定义 UISegmentedControl 的样式，包括修改底色，边框颜色等等。 要了解 UISegmentedControl 各个部分的组成，可以在官方的文档中找到 UISegmentedControl 文档 。着重注意这个图： 上面这幅图明确的列出了 UISegmentedControl 各个部分所控制的方法。下面就开始自定义吧。","text":"系统的 UISegmentedControl 是个挺方便的控件，这里来讲讲在 Swift3 下自定义 UISegmentedControl 的样式，包括修改底色，边框颜色等等。 要了解 UISegmentedControl 各个部分的组成，可以在官方的文档中找到 UISegmentedControl 文档 。着重注意这个图： 上面这幅图明确的列出了 UISegmentedControl 各个部分所控制的方法。下面就开始自定义吧。 首先我们先做一个通过颜色生成图片的的一个扩展方法：1234567891011121314extension UIImage&#123; public class func renderImageWithColor(_ color: UIColor, size: CGSize) -&gt; UIImage &#123; UIGraphicsBeginImageContext(size) guard let context = UIGraphicsGetCurrentContext() else &#123; UIGraphicsEndImageContext() return UIImage() &#125; context.setFillColor(color.cgColor); context.fill(CGRect(x: 0, y: 0, width: size.width, height: size.height)); let img = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return img ?? UIImage() &#125;&#125; 接着，我们可以为 UISegmentedControl 建立一个可以自定义颜色的扩展方法：1234567891011121314151617181920212223242526272829303132extension UISegmentedControl &#123; /// 自定义样式 /// /// - Parameters: /// - normalColor: 普通状态下背景色 /// - selectedColor: 选中状态下背景色 /// - dividerColor: 选项之间的分割线颜色 func setSegmentStyle(normalColor: UIColor, selectedColor: UIColor, dividerColor: UIColor) &#123; let normalColorImage = UIImage.renderImageWithColor(normalColor, size: CGSize(width: 1.0, height: 1.0)) let selectedColorImage = UIImage.renderImageWithColor(selectedColor, size: CGSize(width: 1.0, height: 1.0)) let dividerColorImage = UIImage.renderImageWithColor(dividerColor, size: CGSize(width: 1.0, height: 1.0)) setBackgroundImage(normalColorImage, for: .normal, barMetrics: .default) setBackgroundImage(selectedColorImage, for: .selected, barMetrics: .default) setDividerImage(dividerColorImage, forLeftSegmentState: .normal, rightSegmentState: .normal, barMetrics: .default) let segAttributesNormal: NSDictionary = [NSForegroundColorAttributeName: UIColor.gray, NSFontAttributeName: UIFont.systemFont(ofSize: 14)] let segAttributesSeleted: NSDictionary = [NSForegroundColorAttributeName: UIColor.white,NSFontAttributeName: UIFont.systemFont(ofSize: 14)] // 文字在两种状态下的颜色 setTitleTextAttributes(segAttributesNormal as [NSObject : AnyObject], for: UIControlState.normal) setTitleTextAttributes(segAttributesSeleted as [NSObject : AnyObject], for: UIControlState.selected) // 边界颜色、圆角 self.layer.borderWidth = 0.7 self.layer.cornerRadius = 5.0 self.layer.borderColor = dividerColor.cgColor self.layer.masksToBounds = true &#125;&#125; 这个扩展方法我只暴露了三种颜色的修改，大家可以根据自己需求修改。最后就是使用了，注意这里如果进行了自定义，不能用 autoLayout 了, 需指定 Segement 的位置大小，不然显示出来的效果被压缩成了一条线，我估计是 setBackgroundImage 的方法需要把 1x1 的颜色图片进行填充，如果不指定大小会出差错。12345let segment = UISegmentedControl(items: [\"测试\", \"测试\", \"测试\"])segment.frame = CGRect(x: 0, y: 0, width: 150, height: 40)segment.setSegmentStyle(normalColor: UIColor.clear, selectedColor: UIColor.cyan, dividerColor: UIColor.gray)segment.selectedSegmentIndex = 0view.addSubview(segment) 个人比较喜欢用 extension 扩展方法，这里大家直接拷贝就能够使用了，祝大家自定义愉快吧~","categories":[],"tags":[]}]}